<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IRIMU Matrix Mapper</title>
    <style>
        body {
            margin: 0;
            background: #111;
            color: white;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
        }

        button {
            background: #222;
            color: #fff;
            border: 1px solid #555;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
            margin-right: 5px;
        }

        button:hover {
            background: #444;
        }

        button.active {
            background: #00ff55;
            color: #000;
        }

        #status {
            margin-top: 5px;
            font-size: 14px;
            color: #aaa;
        }

        #canvas-container {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            margin-top: 20px;
            cursor: crosshair;
        }

        canvas {
            display: block;
            border: 2px solid #333;
        }

        .module-selector {
            position: absolute;
            width: 80px;
            height: 80px;
            border: 2px solid white;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 0 2px 4px black;
            user-select: none;
            cursor: move;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(2px);
            transition: border-color 0.2s;
        }
    </style>
</head>

<body>

    <div id="controls">
        <h3>Matrix Mapper (3x ESP32-S3)</h3>
        <div style="margin-bottom: 10px;">
            <button id="connectBtn">Connect USB</button>
            <button id="scanBtn" disabled>SCAN (RX)</button>
            <button id="streamBtn" disabled>STREAM (TX)</button>
        </div>
        <div id="status">Status: Disconnected</div>
        <br>
        <label>Speed: <input type="range" id="speedRange" min="1" max="20" value="5"></label>
    </div>

    <div id="canvas-container">
        <canvas id="mainCanvas" width="1920" height="1080" style="width: 960px; height: 540px;"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        let speed = 5;
        let offset = 0;
        let isStreaming = false;

        // Visual Loop
        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            offset += speed;
            if (offset > 1920) offset -= 1920;

            // Draw Rainbow
            const period = 3;
            for (let x = 0; x < canvas.width; x += period) {
                let hue = ((x + offset) % 1920) / 1920 * 360;
                ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.fillRect(x, 0, 2, canvas.height);
            }

            if (isStreaming && !isWriting) {
                processModules();
            }
            requestAnimationFrame(draw);
        }

        // Web Serial
        let port, writer, reader, keepReading = false;
        let isWriting = false; // Lock to prevent buffer overflow

        const devices = new Map();
        const COLORS = ['#ff0055', '#00ff55', '#0055ff', '#ffff00', '#00ffff', '#ff00ff'];

        document.getElementById('connectBtn').onclick = async () => {
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 921600 });
                writer = port.writable.getWriter();
                keepReading = true;
                readLoop();

                document.getElementById('connectBtn').style.display = 'none';
                document.getElementById('scanBtn').disabled = false;
                document.getElementById('streamBtn').disabled = false;

                // Default to SCAN
                setMode('RX');
            } catch (e) { alert(e); }
        };

        document.getElementById('scanBtn').onclick = () => setMode('RX');
        document.getElementById('streamBtn').onclick = () => setMode('TX');

        async function setMode(mode) {
            if (!writer) return;
            const cmd = (mode === 'RX') ? "MODE:RX" : "MODE:TX";
            const enc = new TextEncoder();
            await writer.write(enc.encode(cmd + '\n'));

            if (mode === 'RX') {
                isStreaming = false;
                document.getElementById('scanBtn').classList.add('active');
                document.getElementById('streamBtn').classList.remove('active');
                document.getElementById('status').textContent = "Status: Scanning (RX)...";
            } else {
                isStreaming = true; // Enable data sending loop
                document.getElementById('scanBtn').classList.remove('active');
                document.getElementById('streamBtn').classList.add('active');
                document.getElementById('status').textContent = "Status: Streaming (TX)...";
            }
        }

        async function readLoop() {
            reader = port.readable.getReader();
            try {
                while (keepReading) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    for (let i = 0; i < value.length; i++) handleByte(value[i]);
                }
            } catch (e) { console.error(e); }
            finally { reader.releaseLock(); }
        }

        // Parser
        let state = 0, pLen = 0, pIdx = 0, pBuf = new Uint8Array(255);
        function handleByte(b) {
            if (state == 0) { if (b == 0xAA) state = 1; }
            else if (state == 1) { if (b == 0xBB) state = 2; else state = 0; }
            else if (state == 2) { pLen = b; pIdx = 0; state = 3; }
            else if (state == 3) { pBuf[pIdx++] = b; if (pIdx >= pLen) state = 4; }
            else if (state == 4) { if (b == 0xCC) state = 5; else state = 0; }
            else if (state == 5) { if (b == 0xDD) processPacket(pBuf.slice(0, pLen)); state = 0; }
        }

        function processPacket(data) {
            // Heartbeat: 'HB' + MAC(6)
            if (data.length >= 8 && data[0] == 0x48 && data[1] == 0x42) {
                const mac = Array.from(data.slice(2, 8)).map(b => b.toString(16).padStart(2, '0')).join(':');
                if (!devices.has(mac)) {
                    let id = devices.size + 1;
                    const mod = { id, mac, macBytes: data.slice(2, 8), x: 200 + (id - 1) * 300, y: 300, color: COLORS[(id - 1) % COLORS.length] };
                    createModule(mod);
                    devices.set(mac, mod);
                }
            }
        }

        const container = document.getElementById('canvas-container');
        function createModule(m) {
            const el = document.createElement('div');
            el.className = 'module-selector';
            el.textContent = m.id;
            el.style.left = (m.x / 2) + 'px'; el.style.top = (m.y / 2) + 'px';
            el.style.borderColor = m.color; el.style.color = m.color;

            let isDragging = false;
            el.onmousedown = () => isDragging = true;
            window.onmouseup = () => isDragging = false;
            window.onmousemove = e => {
                if (!isDragging) return;
                const rect = container.getBoundingClientRect();
                let cx = Math.max(0, Math.min(e.clientX - rect.left - 40, 960 - 80));
                let cy = Math.max(0, Math.min(e.clientY - rect.top - 40, 540 - 80));
                el.style.left = cx + 'px'; el.style.top = cy + 'px';
                m.x = cx * 2; m.y = cy * 2;
            };
            container.appendChild(el);
        }

        async function processModules() {
            if (!writer) return;
            isWriting = true;

            try {
                for (const m of devices.values()) {
                    // Protocol: [0xAA] [0xBB] [0xFC] [MAC 6] [RGB 192]
                    const packet = new Uint8Array(3 + 6 + 192);
                    packet[0] = 0xAA;
                    packet[1] = 0xBB;
                    packet[2] = 0xFC;
                    packet.set(m.macBytes, 3);

                    const step = 160 / 8;
                    let pIdx = 9; // 3 + 6
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            const sx = Math.floor(m.x + c * step + step / 2);
                            const sy = Math.floor(m.y + r * step + step / 2);
                            // Bounds check
                            if (sx < 0 || sx >= 1920 || sy < 0 || sy >= 1080) {
                                pIdx += 3; continue;
                            }
                            const p = ctx.getImageData(sx, sy, 1, 1).data;
                            packet[pIdx++] = p[0]; packet[pIdx++] = p[1]; packet[pIdx++] = p[2];
                        }
                    }
                    await writer.write(packet);
                }
            } catch (e) {
                console.error(e);
            } finally {
                isWriting = false;
            }
        }


        document.getElementById('speedRange').oninput = function () { speed = parseInt(this.value); };
        draw();
    </script>
</body>

</html>